## Работа с монорепозиториями

Если внутри одного репозитория находятся разные независимые части проекта, запустить `ruleguard` на корне рекурсивным образом уже может не получиться.

В этом документе рассматриваются некоторые из проблем, которые могут возникнуть, а так же пути их решения.

### Правила требуют локальные для подпроекта зависимости

Представим такую структуру проекта:

```
root/
  project-a/
  project-b/
  rules.go
  go.mod
```

Здесь два разных корня подпроектов, которые могут содержать свои `go.mod` файлы, либо вообще собираться каким-то отличным от друг друга образом.

В зависимости от способа запуска `ruleguard` на таком проекте, может возникнуть ситуация, когда в правилах используется пакет, доступный в одном проекте,
но недоступный в другом. В этом случае будет выдана ошибка импортов на этапе подгрузки правил.

Чтобы такого не произошло, можно применять несколько хитростей.

Для начала, можно разделить правила на несколько файлов. Общее оставить в корне (или унести в другой, отдельный пакет), а специфичные для подпроекта
правила положить в корне самих подпроектов. Анализировать при таком раскладе можно несколькими способами:

* Запускать `ruleguard` с передачей нескольких файлов правил `-rules shared_rules.go,project_a_rules.go`
* Сделать корневые правила бандлом и импортировать их в каждом вложенном наборе правил

Сейчас в разработке находится [другой способ решения проблемы](https://github.com/go-critic/go-critic/pull/1024). Если ничто из указанных выше
советов не помогает, вам стоит поставить плюсик pull request'у из ссылки (или откройте новый issue, там разберёмся).

TODO: разобрать ситуацию с запуском `golangci-lint` на корне такого проекта.

### Анализаторам (в том числе `ruleguard`) не хватает памяти на обработку проекта целиком

В таких ситуациях нужна либо альтернативная архитектура линтеров, где мы не пытаемся загрузить весь проект в память при анализе,
которой не придерживается почти никто, либо проверка по частям.

Проверять по частям можно разными способами, но самый простой из них - это получить список пакетов через `go list` и запускать весь
анализ по пакетам. Из минусов: повышенное время исполнения анализа, теряем возможность делять полнопрограммный анализ.

Другим способом является запуск анализа по логическому разделению, которое чаще всего приходится расписывать руками в конфиге или
скрипте запуска линтеров. Например, в монорепозитории может быть 5 основных проектов. Мы можем запускать анализ на каждом из них отдельно.
Если даже отдельно взятый проект слишком крупный, то нужно применять для него один из других методов анализа по частям.

Более сложный вариант - это автоматический сбор компонент с зависимостями из проекта, чтобы запускать анализ не только на самом пакете,
но и на его зависимостях. `go list` умеет выдавать список зависимостей:

```bash
$ go list -f '{{ join .Deps  "\n"}}' targetpackage
```

> В интернете есть [неплохие статьи](https://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife) на тему `go list`.

Из этих списков стоит убирать пакеты из стандартной библиотеки. Как получить список пакетов из стандартной библиотеки?

```bash
$ go list std
```
