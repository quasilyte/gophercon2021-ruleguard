## Рекомендацию по внедрению статического анализа

Есть хороший доклад [Practical advanced static analysis](https://www.youtube.com/watch?v=bNdhjiMUBso), в котором затрагиваются
многие нюансы внедрения статического анализа. Несмотря на то, что речь идёт о PHP анализаторах, те же подходы работают
и для любого другого языка. Доклад больше про прагматичный подход к интеграции статического анализа, чем про конкретные линтеры.

Ещё один хороший доклад на тему - [Непрерывный статический анализ кода](https://www.youtube.com/watch?v=_Wv-PvZeRlI).

Данный документ и текущий воркшоп сосредоточены, в основном, на `golangci-lint` и `ruleguard`.

Некоторые базовые вещи:

* Предупреждения линтера должны фейлить пайплайн, но мерж всё равно должен быть доступен для некоторой ответственной группы людей
* Если вы добавляете git push хук с линтерами, то должен иметься флаг для обхода этих линтеров (через env или аргумент `git push`)
* Локальные git push хуки не заменяют линтеров на CI; они нужны только для более быстрой обратной связи

Нужно понимать, что в линтерах бывают баги. Для таких ситуаций у вас должен быть способ влить в репозиторий что-то, что не проходит линтеры.
Если есть возможность, стоит логгировать все события вливания кода в обход линтерам.

### Когда предупреждений на проекте слишком много

Проще всего начать с `golangci-lint`. Он поддерживает режим работы с диффом.

> [golangci-lint/how-to-integrate-golangci-lint-into-large-project-with-thousands-of-issues](https://golangci-lint.run/usage/faq/#how-to-integrate-golangci-lint-into-large-project-with-thousands-of-issues)

Аргументом `--new-from-rev` указывается ревизия, относительно которой нужно искать **новые** предупреждения.
Таким образом, линтер будет выдавать предупреждения только на те строки, которые были затронуты в текущем наборе изменений.

Если вы интегрируете другие линтеры, которые не поддерживают дифф режим, может быть разумно включать их только на относительно новых частях,
где предупреждений не очень много и исправить их не займёт много времени.

Есть немного нестандартный способ решения этой проблемы, который может помочь в случае с внедрением `ruleguard`.
Когда для диагностики написан хороший `Suggest()` шаблон, можно применять автофиксы. Если начать интеграцию только с того, что
вы можете автоматически исправить во всём проекте, то вам не потребуется запуск с diff'ом или любым другим методом подавления старых предупреждений.

> Помимо diff режима есть также baseline подход; различия можно посмотреть в статье [baseline файлы vs diff](https://habr.com/ru/post/508094/).

### Если некоторые из диагностик вызывают недовольство разработчиков

Самое важное: не допускать практики заглушки линтера с помощью `//nolint`. Эта директива может быть использована только в крайних случаях.
Например, в линтере есть баг, а вам не очевидно, как упростить код, чтобы он его понял.
Почти всегда `nolint` стоит сопровождать комментарием, которые ответит, почему эта директива здесь была добавлена.

Если в вашей команде нет единого и строгого стиля, то демократический путь - это отключать те диагностики, которые тормозят работу
или вызывают недовольство. Вы можете попробовать делать разные конфиги для разных подпроектов.

Если команда привыкла следовать строгим стандартам, то здесь мы возвращаемся к тому, что `//nolint` всё равно имеет мало смысла:
вы либо исправляете код под общий стиль, либо что-то в этой системе не работает и надо пересматривать общий гайд стиля (или процессы).

Стилистические проверки особенно полезны для начинающих разработчиков и тех, кто перешёл в Go с другого языка программирования.
Они подскажут им, какие конструкции являются более идиоматичными. Мы также выигрываем в консистентности кода, так как линтеры,
обычно, предпочитают один вариант написания нескольким аналогичным.

Я считаю, что разделения на strict и non-strict части проекта бывает достаточно. Причём включение в strict группу должно выполняться
добровольно, самой командой. В strict конфиге мы включаем больше диагностик, в non-strict только те, что удовлетворяют почти всех.

### Рекомендации от [@ernado](https://github.com/ernado), меинтейнера [golangci-lint](https://github.com/golangci/golangci-lint)

* Не забывайте про exclude rules `(1)`
* Дефолты линтеров - не истина последней инстанции
* Не бойтесь выключать то, что мешает разрабатывать

`(1)` Имеется в виду, что вы можете отключать некоторые конкретные виды сообщений от линтеров. Например, у `golint` можно выключить
сообщения о том, что каждому экспортируемому символу нужен комментарий.

### Рекомендации от [@cristaloleg](https://github.com/cristaloleg)

* Включайте линтеры постепенно. Сперва просто на CI, без фейла билда; потом чистите пакетами, потом требуйте зеленых билдов
* Больше линтеров != лучше код. Линтеры разные, код разный, проекты разные, все нужно смотреть по ситуации
* Запуск линтера локально должен быть такой же как на CI. Следите за версиями, конфигом и лёгкостью использования
* Исключайте неинтересные директори. Вендор, кодген, условно какой-то фронтенд с node_modules
* Линтеры не панацея. Они, скорее вам помогут, но не спасут от всего
* `//nolint` на весь файл или функцию - это плохо; лучше выключить диагностику или директорию, чем засорять код этим

### Рекомендации от [@onokonem](https://github.com/onokonem)

* Сразу планируйте то, что ваш линтер окажется в golangci-lint. Постарайтесь не пересекаться по функциональности с другими включенными в него линтерами
* Если ваш линтер можно написать на ruleguard - так и надо поступить
* Если ваш линтер в принципе может поддерживать autofix - его надо написать обязательно
* Тесты линтера - это сложная работа, нужно покрыть много граничных случаев; это может занимать много времени (иногда больше, чем написание самого линтера)
* False positive срабатываний должно быть как можно меньше; если выбор между false positive и false negative, то делайте выбор в пользу false negative
