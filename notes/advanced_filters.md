## Продвинутая фильтрация

### Паттерны типов

Фильтр `Type.Is` принимает строку-шабон, как и `Match()`.

Вот несколько примеров:

| Шаблон | Результат | Пример |
|---|---|---|
| `$t` | Любой тип | `int` |
| `[]byte` | Слайс байтов | `[]byte` |
| `[]$t` | Слайс с элементами произвольного типа | `[]int` |
| `[$_]int` | Массив `int` произвольной длины | `[5]int` |
| `[2]$_` | Массив из двух элементов произвольного типа | `[2]string` |
| `map[$t]$t]` | map, в котором ключи и значения имеют одинаковый тип | `map[string]string` |
| `map[$k]struct{}` | Идиома "set map" в Go | `map[uint]struct{}` |
| `func ($_) $_` | Тип функции с 1 входным аргументом и 1 результатом | `func(int) string` |
| `struct{$*_}` | Любая структура | `struct{x int; y string}` |
| `struct{$x; $x}` | Структура из двух полей идентичного типа | `struct{x, y int}` |
| `struct{$_; $x}` | Структура из любых двух полей | `struct{x int; y int}` |
| `struct{int; $*_}` | Структура, в которой первое поле имеет тип `int` | `struct{x int; y string; z byte}` |
| `struct{$*_; int}` | Структура, в которой последнее поле имеет тип `int` | `struct{x byte; y string; z int}` |
| `struct{$*_; int; $*_}` | Структура, которая содержит поле типа `int` | `struct{x int}` |

### Фильтры текста

Когда мы рассматриваем `Match()` паттерн вроде `f( $x )`, мы работаем на уровне AST. Пробелы между `$x` и скобочками не влияют на матчинг.

Однако мы можем опускаться до уровня текста в некоторых случаях. Например, мы можем проверить, что в переменной шаблона `$x` находится
переменная с именем `err`:

```go
Where(m["x"].Text == "err")
```

Присваивания переменной самой себе обычно описываются как `$x = $x`, однако можно сделать и через текст:

```go
m.Match(`$x = $y`).Where(m["x"].Text == m["y"].Text)
```

В данном случае пробелы и прочие незначительные вещи могут влиять на матчинг.

Также поддерживаются фильтры текста по регуляркам:

```go
Where(m["x"].Text.Matches(`regexp-pattern`)
```

### Вычисление константных выражений

В фильтрах мы можем выставлять условия, основанные на значениях, в которые может вычисляться выражение на этапе компиляции.

Например, если в переменную шаблона `$x` попало `Foo + 1`, а константа `Foo` определена как `11`, то мы можем понять, что
значение `Foo + 1` равно `12`. Получить это значение можно так: `m["x"].Value.Int()`.

```go
func badRangeCheck(m dsl.Matcher) {
	m.Match(`$x < $a && $x > $b`).
		Where(m["a"].Value.Int() <= m["b"].Value.Int()).
		Report("the condition is always false because $a <= $b")

	m.Match(`$x > $a && $x < $b`).
		Where(m["a"].Value.Int() >= m["b"].Value.Int()).
		Report("the condition is always false because $a >= $b")
}
```

### Pure и Const флаги

Эти два флага полезны для избежания ложных срабатываний.

Допустим, мы хотим предлагать переписывать `$x = $x + $y` как `$x += $y`; но что, если `$x` - не простая переменная,
а вызов функции с побочными эффектами? В таком случае вызов будет происходить 1 раз вместо изначальных двух, что не эквивалентно.

В этой ситуации нам помогает флаг `Pure`, который гарантирует, что повторное вычисление выражения должно приводить к тем же результатам.
Следовательно, это выражение можно убирать или дублировать, если нам это нужно.

```go
func assignOp(m dsl.Matcher) {
  m.Match(`$x = $x + $y`).
    Where(m["x"].Pure).
    Report(`can simplify to $x+=$y`)
}
```

Более сильным, чем `Pure`, является флаг `Const`. Он гарантирует, что выражение является константным. То есть его можно использовать в
контекстах, где в Go разрешены константные выражения (размер массива, значение именованной константы и так далее).

Константами являются некоторые литералы (числа, строки, ...), а также именованные константы и некоторые другие выражения, типа `unsafe.Sizeof()`.

```go
func durationExprSimplify(m dsl.Matcher) {
	m.Match(`time.Duration($x) * time.Second`).
		Where(m["x"].Const).
		Report(`rewrite as '$x * time.Second'`)
}

func oddArgsOrder(m dsl.Matcher) {
	m.Match(`strings.HasPrefix($s1, $s2)`).
		Where(m["s1"].Const && !m["s2"].Const).
		Suggest(`strings.HasPrefix($s2, $s1)`)
}
```

### Проверка типов AST элементов

Иногда мы хотим ограничить матчинг так, чтобы он срабатывал только на определённые типы AST узлов.

Делается это через фильтр `m["x"].Node.Is("type")`.

Например, если мы хотим проверять на `*ast.CompositeLit`, то указывать в строковом аргументе стоит `"CompositeLit"`.

```go
func reflectValueCompare(m dsl.Matcher) {
	m.Match(`reflect.DeepEqual($x, $y)`).
		Where(m["x"].Type.Is(`reflect.Value`) &&
			m["y"].Type.Is(`reflect.Value`) &&
			!m["x"].Node.Is(`CompositeLit`) &&
			!m["y"].Node.Is(`CompositeLit`)).
		Report("avoid using reflect.DeepEqual with reflect.Value").
		Suggest("reflect.DeepEqual($x.Interface(), $y.Interface()")
}
```
